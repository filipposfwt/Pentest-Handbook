# iOS practical

## Jailbreak
There are multiple jailbreaks available, depending on the firmware and device model, different jailbreak will apply. 

[AppleDB](https://appledb.dev) - Finding the device model and firmware to check which JB are available.
[ios.cfw.guid](https://ios.cfw.guide/get-started/) -  Provides precautions and instructions on what to mind in every jailbreak.

The most famous jailbreaks are [checkra1n](https://checkra.in/), [palera1n](https://palera.in/) and [uncover](https://unc0ver.dev/).

iOS apps are bundled in **IPA** zip archive. 

```
unzip -d <output_name> <zip_name>
```

Binaries are all signed by Apple, otherwise iOS refuses to execute them if they are not signed. 

Located in <kbd>Code signatures</kbd> → <kbd>CodeResources.xml</kbd>

To view architecture of the binary: 

```
xcrun -sdk iphoneos lipo -info <binary_name>
```

To locate certain strings inside the app : 

```
strings <binary_name>
```

Open the binary in **IDA** or **Frida** dissassembler. 

The same functionality with strings can be found in symbols search in IDA.

If an app really needs to have hardcoded secrets but not secrets, the developers can encode the string. Obfuscate it using anything like XOR. Another option is to encrypt the binary section which contains the strings. Binaries have some constructors that run before main, so the decryption algorithm can be called inside such a constructor, if an attacker have access to the binary at rest they will not be able to see the strings so easily.

Any application has a directory in which is installed and stores its data in:

```
 /private/var/mobile/Containers/Data/Application
```

In order to find where our app is we can use the command:

```
find / -name “*<binary_name>*”
```

If there is a **plist** file we can copy it to our computer. To convert the plist to xml we can use:

```
plistutil -i <filename>
```
## Static Analysis

For static analysis of iOS binaries the tools to use are [Ghidra](https://github.com/NationalSecurityAgency/ghidra) and [Hopper](https://www.hopperapp.com/).

[MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF) can be used to see binary information, general app info, list of strings, the permissions of the app, and a list of issues.

For a quick setup simply run:

```
docker pull opensecurity/mobile-security-framework-mobsf:latest
docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```

## Dynamic Instrumentation

Dynamic Instrumentation with [Frida](https://github.com/frida), to intercept function calls, check function arguments and function return values and be able to change the apps control flow. Works well for mobile native applications (ObjC/Swift, native libraries, binaries compiled from C, C++, rust etc).

Another dynamic analysic tool which is basically based on Frida is [Objection](https://github.com/sensepost/objection). Objection has ready scripts for dumping application keychain, cookies, or check for ssl pinning bypass etc.:

```
Objection -g <binary_name> explore

Options:

    • ios keychain dump
    • ios cookies get
```

A rooted device is needed for all the above, unless values are stored in the secure enclave. 

## Bypassing the jailbreak check

In frida check the symbols for the word jailbreak to find the function in which the check is implemented. Next we need to hook the application, essentially patching the function with our own code. To patch the app with frida we use:

```
frida -U -f -com.example.<app_name> -l <custom_function_name.js> --no-pause
```

If the method was in a c method and its symbol was stripped from the binary we would not be able to do this. In this case, we have to replace the method by chance. We should find the offset of the method but we don’t know where the binary is loaded in memory because of ASLR. We should find the address of the binary in the memory, we will look for a function or method for which we have the symbol (there is always gonna be a method with known symbols).
